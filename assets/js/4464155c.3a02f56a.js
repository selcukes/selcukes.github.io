"use strict";(self.webpackChunkSelcukes=self.webpackChunkSelcukes||[]).push([[7323],{6808:(e,r,i)=>{i.r(r),i.d(r,{assets:()=>c,contentTitle:()=>d,default:()=>v,frontMatter:()=>l,metadata:()=>n,toc:()=>h});const n=JSON.parse('{"id":"guides/webdriver-binaries","title":"WebDriver Binaries","description":"WebDriver Binaries is an open-source Java","source":"@site/docs/03_guides/webdriver-binaries.md","sourceDirName":"03_guides","slug":"/guides/webdriver-binaries","permalink":"/docs/guides/webdriver-binaries","draft":false,"unlisted":false,"editUrl":"https://github.com/selcukes/selcukes.github.io/tree/main/docs/03_guides/webdriver-binaries.md","tags":[],"version":"current","sidebarPosition":10,"frontMatter":{"id":"webdriver-binaries","title":"WebDriver Binaries","sidebar_position":10},"sidebar":"defaultSidebar","previous":{"title":"Selcukes logger","permalink":"/docs/guides/logger"},"next":{"title":"DataTable","permalink":"/docs/collections/data-table"}}');var t=i(4848),s=i(8453),a=i(1470),o=i(9365);const l={id:"webdriver-binaries",title:"WebDriver Binaries",sidebar_position:10},d=void 0,c={},h=[{value:"Motivation",id:"motivation",level:2},{value:"Setup",id:"setup",level:2},{value:"Driver Management",id:"driver-management",level:2},{value:"Resolution Algorithm",id:"resolution-algorithm",level:2},{value:"Advanced Configuration",id:"advanced-configuration",level:2}];function u(e){const r={a:"a",code:"code",em:"em",h2:"h2",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.a,{href:"https://github.com/selcukes/selcukes-java/tree/master/webdriver-binaries",children:"WebDriver Binaries"})," is an open-source Java\nlibrary that automatically downloads and configures the binary drivers (e.g., chromedriver, geckodriver, msedgedriver,\netc.) required by Selenium WebDriver."]}),"\n",(0,t.jsx)(r.h2,{id:"motivation",children:"Motivation"}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.a,{href:"https://www.selenium.dev/documentation/webdriver/",children:"Selenium WebDriver"})," is a library that allows controlling web\nbrowsers programmatically. It provides a cross-browser API that can be used to drive web browsers (e.g., Chrome, Edge,\nor Firefox, among others) using different programming languages (e.g., Java, JavaScript, Python, C#, or Ruby). The\nprimary use of Selenium WebDriver is implementing automated tests for web applications."]}),"\n",(0,t.jsxs)(r.p,{children:["Selenium WebDriver carries out the automation using the native support of each browser. For this reason, we need to\nplace a binary file called ",(0,t.jsx)(r.em,{children:"driver"})," between the test using the Selenium WebDriver API and the browser to be controlled.\nExamples of drivers for major web browsers nowadays are ",(0,t.jsx)(r.a,{href:"https://chromedriver.chromium.org/",children:"chromedriver"})," (for Chrome)\n, ",(0,t.jsx)(r.a,{href:"https://github.com/mozilla/geckodriver/",children:"geckodriver"})," (for Firefox),\nor ",(0,t.jsx)(r.a,{href:"https://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver/",children:"msedgedriver"})," (for Edge). As you can see in\nthe following picture, the communication between the WebDriver API and the driver binary is done using a standard\nprotocol called ",(0,t.jsx)(r.a,{href:"https://www.w3.org/TR/webdriver/",children:"W3C WebDriver"})," (formerly the so-called ",(0,t.jsx)(r.em,{children:"JSON Wire Protocol"}),"). Then,\nthe communication between the driver and the browser is done using the native capabilities of each browser."]}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.img,{alt:"Architecture",src:i(6938).A+"",width:"718",height:"189"})}),"\n",(0,t.jsxs)(r.p,{children:["From a practical point of view, we need to make a ",(0,t.jsx)(r.em,{children:"driver management process"})," to use Selenium WebDriver. This process\nconsists on:"]}),"\n",(0,t.jsxs)(r.ol,{children:["\n",(0,t.jsx)(r.li,{children:"Download. Drivers are platform-specific binary files. To download the proper driver, we have to identify the driver\ntype we need (e.g., chromedriver if we want to use Chrome), the operating system (typically, Windows, Linux, or Mac\nOS), the architecture (typically, 32 or 64 bits), and very important, the driver version. Concerning the version,\neach driver release is usually compatible with a given browser version(s). For this reason, we need to discover the\ncorrect driver version for a specific browser release (typically reading the driver documentation or release notes)."}),"\n",(0,t.jsxs)(r.li,{children:["Setup. Once we have downloaded the driver to our computer, we need to provide a way to locate this driver from our\nSelenium WebDriver tests. In Java, this setup can be done in two different ways. First, we can add the driver\nlocation to our ",(0,t.jsx)(r.code,{children:"PATH"})," environmental variable. Second, we can use ",(0,t.jsx)(r.em,{children:"Java system properties"})," to export the driver path.\nEach driver path should be identified using a given system property, as follows:"]}),"\n"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:'System.setProperty("webdriver.chrome.driver","/path/to/chromedriver");\nSystem.setProperty("webdriver.gecko.driver","/path/to/geckodriver");\nSystem.setProperty("webdriver.edge.driver","/path/to/msedgedriver");\nSystem.setProperty("webdriver.opera.driver","/path/to/operadriver");\nSystem.setProperty("webdriver.ie.driver","C:/path/to/IEDriverServer.exe");\n'})}),"\n",(0,t.jsxs)(r.ol,{start:"3",children:["\n",(0,t.jsxs)(r.li,{children:["Maintenance. Last but not least, we need to warranty the compatibility between driver and browser in time. This step\nis relevant since modern browsers automatically upgrade themselves (i.e., they are ",(0,t.jsx)(r.em,{children:"evergreen"}),' browsers), and for\nthis reason, the compatibility driver-browser is not warranted in the long run. For instance, when a WebDriver test\nusing Chrome faces a driver incompatibility, it reports the following error message: "',(0,t.jsx)(r.em,{children:"this version of chromedriver\nonly supports chrome version N"}),'." As you can see\nin',(0,t.jsx)(r.a,{href:"https://stackoverflow.com/search?q=this+version+of+chromedriver+only+supports+Chrome+version",children:"StackOverflow"}),",\nthis is a recurrent problem for manually managed drivers (chromedriver in this case)."]}),"\n"]}),"\n",(0,t.jsx)(r.h2,{id:"setup",children:"Setup"}),"\n",(0,t.jsxs)(r.p,{children:["WebDriver Binaries is primarily used as a Java dependency . We typically use a ",(0,t.jsx)(r.em,{children:"build tool"})," (such\nas ",(0,t.jsx)(r.a,{href:"https://maven.apache.org/",children:"Maven"})," or ",(0,t.jsx)(r.a,{href:"https://gradle.org/",children:"Gradle"}),") to resolve the WebDriver Binaries dependency."]}),"\n","\n",(0,t.jsxs)(a.A,{defaultValue:"maven",values:[{label:"Maven",value:"maven"},{label:"Gradle",value:"gradle"}],children:[(0,t.jsx)(o.A,{value:"maven",children:(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-xml",children:"\n<dependency>\n    <groupId>io.github.selcukes</groupId>\n    <artifactId>webdriver-binaries</artifactId>\n    <version>${selcukes.version}</version>\n    <scope>test</scope>\n</dependency>\n"})})}),(0,t.jsx)(o.A,{value:"gradle",children:(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:'dependencies{\n        testImplementation("io.github.selcukes:webdriver-binaries:${selcukes.version}")\n}\n'})})})]}),"\n",(0,t.jsx)(r.h2,{id:"driver-management",children:"Driver Management"}),"\n",(0,t.jsxs)(r.p,{children:["The primary use of WebDriver Binaries is the automation of driver management. For using this feature, you need to select\na given driver in the WebDriver Binaries API (e.g., ",(0,t.jsx)(r.code,{children:"chromeDriver()"})," for Chrome) and invoke the method ",(0,t.jsx)(r.code,{children:"setup()"}),". The\nfollowing example shows a test case using ",(0,t.jsx)(r.a,{href:"https://testng.org/doc/",children:"TestNG"}),", Selenium WebDriver, WebDriver Binaries. In\nthis test, we invoke WebDriver Binaries in the setup method for all tests (",(0,t.jsx)(r.code,{children:"@BeforeClass"}),"). This way, the required\nbinary (chromeDriver) will be available for all the WebDriver tests using Chrome in this class."]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:"public class WebDriverTest {\n\n    private WebDriver driver;\n\n    @BeforeClass\n    public static void setupClass() {\n        WebDriverBinary.chromeDriver().setup();\n    }\n\n    @Before\n    public void setupTest() {\n        driver = new ChromeDriver();\n    }\n\n    @After\n    public void teardown() {\n        if (driver != null) {\n            driver.quit();\n        }\n    }\n\n    @Test\n    public void test() {\n        // Your test code here\n    }\n\n}\n"})}),"\n",(0,t.jsxs)(r.p,{children:["WebDriver Binaries provides a set of ",(0,t.jsx)(r.em,{children:"binaries"})," for Chrome, Firefox, Edge, Opera, Chromium, and Internet Explorer. The\nbasic use of these binary is the following:"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:"WebDriverBinary.chromeDriver().setup();\nWebDriverBinary.firefoxDriver().setup();\nWebDriverBinary.ieDriver().setup();\nWebDriverBinary.edgeDriver().setup();\n WebDriverBinary.operaDriver().setup();\n"})}),"\n",(0,t.jsx)(r.h2,{id:"resolution-algorithm",children:"Resolution Algorithm"}),"\n",(0,t.jsxs)(r.p,{children:["WebDriver Binaries executes a ",(0,t.jsx)(r.em,{children:"resolution algorithm"})," when calling to ",(0,t.jsx)(r.code,{children:"setup()"})," in a given manager. The most relevant\nparts of this algorithm are the following:"]}),"\n",(0,t.jsxs)(r.ol,{children:["\n",(0,t.jsxs)(r.li,{children:["WebDriverBinary tries to find the browser version. To this aim, WebDriverBinary uses internally a knowledge database\ncalled commands' database. This database is a collection of shell commands used to discover the version of a given\nbrowser in the different operating systems (e.g., ",(0,t.jsx)(r.code,{children:"google-chrome --version"})," for Chrome in Linux)."]}),"\n",(0,t.jsxs)(r.li,{children:["Using the browser version, it tries to find the proper driver version. This process is different for each browser. In\nChrome and Edge, their respective drivers (chromedriver and msedgedriver) maintainers also publish resources to\nidentify the suitable driver version for a given major browser release. For instance, to find out the version of\nchromedriver required for Chrome 100, we need to read the\nfollowing ",(0,t.jsx)(r.a,{href:"https://chromedriver.storage.googleapis.com/LATEST_RELEASE_100",children:"file"}),"."]}),"\n",(0,t.jsxs)(r.li,{children:["Once the driver version is discovered, WebDriverBinary downloads this driver to a local cache (located\nat ",(0,t.jsx)(r.code,{children:"%temp%/webdrivers"})," by default). These drivers are reused in subsequent calls."]}),"\n",(0,t.jsxs)(r.li,{children:["Finally, WebDriverBinary exports the driver path using Java system properties (e.g., ",(0,t.jsx)(r.code,{children:"webdriver.chrome.driver"})," in the\ncase of the Chrome manager)."]}),"\n"]}),"\n",(0,t.jsxs)(r.p,{children:["This process automated the first two stages of the driver management previously introduced, i.e., download and setup. To\nsupport the third stage (i.e., maintenance), WebDriverBinary implements ",(0,t.jsx)(r.em,{children:"resolution cache"}),". This cache (called by\ndefault ",(0,t.jsx)(r.code,{children:"version.properties"})," and stored in the root of the driver cache) is a file that stores the relationship between\nthe resolved driver and browser versions. This relationship is valid during a given ",(0,t.jsx)(r.em,{children:"time-to-live"})," (TTL). The default\nvalue for this TTL is 1 hour for browsers and drivers. In other words, the discovered browser version is valid for 1\nhour. This mechanism improves the performance dramatically since the second (and following) calls to the resolution\nalgorithm for the same browser are resolved using only local resources (i.e., without using the shell nor requesting\nexternal services)."]}),"\n",(0,t.jsx)(r.h2,{id:"advanced-configuration",children:"Advanced Configuration"}),"\n",(0,t.jsxs)(r.p,{children:["WebDriver Binaries provides different ways of configuration. First, by using its ",(0,t.jsx)(r.em,{children:"Java API"}),". To that aim, each manager (\ne.g., ",(0,t.jsx)(r.code,{children:"chromeDriver()"}),", ",(0,t.jsx)(r.code,{children:"firefoxDriver()"}),", etc., allows to concatenate different methods of this API to specify custom\noptions or preferences. For example (the explanation of these methods and the other possibilities are explained in the\ntables at the end of this section):"]}),"\n",(0,t.jsxs)(r.table,{children:[(0,t.jsx)(r.thead,{children:(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.th,{children:"Description"}),(0,t.jsx)(r.th,{children:"Method"})]})}),(0,t.jsxs)(r.tbody,{children:[(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:"Download the latest binary"}),(0,t.jsxs)(r.td,{children:["WebDriverBinary.chromeDriver().setup(); ",(0,t.jsx)("br",{})," WebDriverBinary.firefoxDriver().setup(); ",(0,t.jsx)("br",{})," WebDriverBinary.ieDriver().setup(); ",(0,t.jsx)("br",{})," WebDriverBinary.edgeDriver().setup(); ",(0,t.jsx)("br",{})," WebDriverBinary.edgeDriver().setup(); ",(0,t.jsx)("br",{})," WebDriverBinary.operaDriver().setup(); ",(0,t.jsx)("br",{})," WebDriverBinary.grid().setup();"]})]}),(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:"Download binaries for specific architecture"}),(0,t.jsxs)(r.td,{children:["WebDriverBinary.chromeDriver().arch64().setup(); ",(0,t.jsx)("br",{})," WebDriverBinary.firefoxDriver().arch32().setup();"]})]}),(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:"Download binaries by specifying custom download location"}),(0,t.jsx)(r.td,{children:'WebDriverBinary.chromeDriver().targetPath("temp").setup(); WebDriverBinary.firefoxDriver().targetPath("downloadLocation").setup();'})]}),(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:"Download binaries for a specific release version"}),(0,t.jsx)(r.td,{children:'WebDriverBinary.firefoxDriver().version("v0.26.0").setup();'})]})]})]})]})}function v(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,t.jsx)(r,{...e,children:(0,t.jsx)(u,{...e})}):u(e)}},9365:(e,r,i)=>{i.d(r,{A:()=>a});i(6540);var n=i(4164);const t={tabItem:"tabItem_Ymn6"};var s=i(4848);function a({children:e,hidden:r,className:i}){return(0,s.jsx)("div",{role:"tabpanel",className:(0,n.A)(t.tabItem,i),hidden:r,children:e})}},1470:(e,r,i)=>{i.d(r,{A:()=>D});var n=i(6540),t=i(4164),s=i(7559),a=i(3104),o=i(6347),l=i(205),d=i(7485),c=i(1682),h=i(679);function u(e){return n.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,n.isValidElement)(e)&&function(e){const{props:r}=e;return!!r&&"object"==typeof r&&"value"in r}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function v(e){const{values:r,children:i}=e;return(0,n.useMemo)((()=>{const e=r??function(e){return u(e).map((({props:{value:e,label:r,attributes:i,default:n}})=>({value:e,label:r,attributes:i,default:n})))}(i);return function(e){const r=(0,c.XI)(e,((e,r)=>e.value===r.value));if(r.length>0)throw new Error(`Docusaurus error: Duplicate values "${r.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[r,i])}function m({value:e,tabValues:r}){return r.some((r=>r.value===e))}function p({queryString:e=!1,groupId:r}){const i=(0,o.W6)(),t=function({queryString:e=!1,groupId:r}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!r)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return r??null}({queryString:e,groupId:r});return[(0,d.aZ)(t),(0,n.useCallback)((e=>{if(!t)return;const r=new URLSearchParams(i.location.search);r.set(t,e),i.replace({...i.location,search:r.toString()})}),[t,i])]}function b(e){const{defaultValue:r,queryString:i=!1,groupId:t}=e,s=v(e),[a,o]=(0,n.useState)((()=>function({defaultValue:e,tabValues:r}){if(0===r.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!m({value:e,tabValues:r}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${r.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const i=r.find((e=>e.default))??r[0];if(!i)throw new Error("Unexpected error: 0 tabValues");return i.value}({defaultValue:r,tabValues:s}))),[d,c]=p({queryString:i,groupId:t}),[u,b]=function({groupId:e}){const r=function(e){return e?`docusaurus.tab.${e}`:null}(e),[i,t]=(0,h.Dv)(r);return[i,(0,n.useCallback)((e=>{r&&t.set(e)}),[r,t])]}({groupId:t}),f=(()=>{const e=d??u;return m({value:e,tabValues:s})?e:null})();(0,l.A)((()=>{f&&o(f)}),[f]);return{selectedValue:a,selectValue:(0,n.useCallback)((e=>{if(!m({value:e,tabValues:s}))throw new Error(`Can't select invalid tab value=${e}`);o(e),c(e),b(e)}),[c,b,s]),tabValues:s}}var f=i(2303);const g={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var x=i(4848);function w({className:e,block:r,selectedValue:i,selectValue:n,tabValues:s}){const o=[],{blockElementScrollPositionUntilNextRender:l}=(0,a.a_)(),d=e=>{const r=e.currentTarget,t=o.indexOf(r),a=s[t].value;a!==i&&(l(r),n(a))},c=e=>{let r=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const i=o.indexOf(e.currentTarget)+1;r=o[i]??o[0];break}case"ArrowLeft":{const i=o.indexOf(e.currentTarget)-1;r=o[i]??o[o.length-1];break}}r?.focus()};return(0,x.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,t.A)("tabs",{"tabs--block":r},e),children:s.map((({value:e,label:r,attributes:n})=>(0,x.jsx)("li",{role:"tab",tabIndex:i===e?0:-1,"aria-selected":i===e,ref:e=>{o.push(e)},onKeyDown:c,onClick:d,...n,className:(0,t.A)("tabs__item",g.tabItem,n?.className,{"tabs__item--active":i===e}),children:r??e},e)))})}function y({lazy:e,children:r,selectedValue:i}){const s=(Array.isArray(r)?r:[r]).filter(Boolean);if(e){const e=s.find((e=>e.props.value===i));return e?(0,n.cloneElement)(e,{className:(0,t.A)("margin-top--md",e.props.className)}):null}return(0,x.jsx)("div",{className:"margin-top--md",children:s.map(((e,r)=>(0,n.cloneElement)(e,{key:r,hidden:e.props.value!==i})))})}function j(e){const r=b(e);return(0,x.jsxs)("div",{className:(0,t.A)(s.G.tabs.container,"tabs-container",g.tabList),children:[(0,x.jsx)(w,{...r,...e}),(0,x.jsx)(y,{...r,...e})]})}function D(e){const r=(0,f.A)();return(0,x.jsx)(j,{...e,children:u(e.children)},String(r))}},6938:(e,r,i)=>{i.d(r,{A:()=>n});const n=i.p+"assets/images/selenium-webdriver-architecture-dfeb30760c997a9cbe6ccb4a963b4d3c.png"},8453:(e,r,i)=>{i.d(r,{R:()=>a,x:()=>o});var n=i(6540);const t={},s=n.createContext(t);function a(e){const r=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function o(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),n.createElement(s.Provider,{value:r},e.children)}}}]);